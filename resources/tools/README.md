# DSI scripts
This folder contains useful scripts for working with DSI.

## Overview of scripts

| File | Description |
| ----------- |-------------|
| cleanTrace.sh | Post-processes a trace file generated by DSI to remove unneeded information/symbols. |
| navigateDot.sh | Navigates through all DOT files in the directory in which the script is started (see below). |
| navigateLog.sh | Navigates through the log file produced by DSI if dsi-logger is enabled. The log file is sliced into smaller files, one for each time step of the trace. |
| refine-all-types.sh | Refines all binary types (see main README in DSI's git repository website) by calling type-refinement.pl on each test program found in the given directory. |
| type-refinement.pl | Triggers the type-refinement step of DSI (see main README in DSI's git repository website). |
| select-all-types.sh | Selects the refined types produced by refine-all-types.sh, by calling select-interpretation.pl on each test program found in the given directory. |
| select-interpretation.pl | Selects the most complex type of a given type-refinement (see main README in DSI's git repository website).|


## Using `navigateDot.sh` to visualize the generated graphs
DSI will generate dot files that can, e.g., be visualized using the tool `xdot`. Execute `$ sudo apt-get install xdot` to install `xdot`.

The `navigateDot.sh` script can be used to foster visualization of the generated graphs. Note that this script is not meant to be a full visualization. It is rather a wrapper script that uses `xdot` to render the graphs, and provides simple means to jump from/to events. This script does not represent the DSI visualization back end component. In order to use the script, run it from a folder that contains graphs, i.e., dot files. The script provides the following functionality for the keys listed below:
* `f`: Jump to the first event press.
* `a`: Jump to the previous event.
* `d`: Jump to the next event.
* `s`: Exit the script and kill the opened xdot processes.
* `e`: Jump to a specified event.
* `n`: Jump to the specific index of all generated dot files.


## Using DSIref to improve Howard's type information
Because DSIbin does not have access to the rich type information provided by source code, this information must be inferred. In case of DSIbin, this is done by the type excavator Howard [[3]]. In order to improve the results inferred by Howard, these are subsequently refined using DSI's refinement component DSIref; for further details see [[1],[2]].
Note that in order to run the DSIref component, the binary instrumentation has to be reapplied to the x86 executable.
This can be done for all synthetic examples, because the source code is directly located in this repository. However, the textbook examples, real-world examples, and the examples taken from the shape analysis literature are not part of this repository.
Please obtain the original source code from the publishers webpage as listed in our publications.
However, the initial types excavated by Howard are located in the test program's folder, i.e., the data structures as seen by Howard without further refinement.
These can be used to run DSIbin in order to detect the data structures used by the program under analysis.

**Remark:** Make sure that `type-refinement.pl` and `refine-all-types.sh` always run with root rights; `sudo` will most probably timeout during the computation and will thus cause problems.
Hence, either (i) run the script in a full root shell (i.e., invoked via `sudo su`) or (ii) adjust the `sudo` timeout (i.e., by adding `Defaults timestamp_timeout=-1` via `sudo visudo`).


### Applying `type-refinement.pl` to a single example
The `type-refinement.pl` script can be used to execute DSI's type refinement algorithm. Before executing the script, certain parameters must be adapted inside this script. See the comments in the script for further advice.

To run the DSI refinement component on a single test program, execute the following command from within the tools folder. Make sure to adjust the path with respect to your local setting:  
```
$ sudo ./type-refinement.pl /path/to/DSI-bin/resources/test-programs/<example> /path/to/DSI-bin/resources/xml/ /path/to/DSI-bin-inst/obj-intel64/ binary-tree;
```
**Note:** This computation might take some time depending on your hardware setting. 


### Applying `type-refinement.pl` to multiple examples via `refine-all-types.sh`
In order to compute the refinement for multiple examples, the `refine-all-types.sh` script can be used to coordinate the execution of the abovementioned `type-refinement.pl` scripts.
Parameters can be specified within this script; however, parameters specifying the path of certain components must be adapted inside the `refine-all-types.sh` script before execution.

Execute the following command to run the DSI refinement component on all provided test programs:
```
$ sudo ./refine-all-types.sh /absolute/path/to/DSI-bin/resources/test-programs/
```
For each example this will generate the aggregated strand graphs of each type hypothesis.
**Note:** Make sure to adjust the path with respect to your local setting. Moreover, the above computation might take some time depending on your hardware setting. 


## Selecting type interpretation using `select-interpretation.pl` and `select-all-types.sh`
Execute `select-interpretation.pl` to retrieve the refined type; the script returns, for a single test program, its most complex data structure interpretation as identified by DSIbin:

```
$ ./select-interpretation.pl /absolute/path/to/DSI-bin/resources/test-programs/<example>/dsi-refined-types/ | sed -n -e '/Print clustered/,$p'
```

Use the `select-all-types.sh` to retrieve the refined type result from multiple test cases:

```
$ ./select-all-types.sh /absolute/path/to/DSI-bin/resources/test-programs/
```

Consult [[2]] regarding the algorithm that retrieves the most complex data structure interpretation.


## References
1. T. Rupprecht, J. H. Boockmann, D. H. White, and G. Lüttgen. DSI: Automated Detection of Dynamic Data
Structures in C Programs and Binary Code. In 19th Coll. on Programming Languages and Foundations of Programming (Kolloquium Programmiersprachen, KPS ’17), 2017. To appear online.
2. T. Rupprecht, X. Chen, D. H. White, J. H. Boockmann, G. Lüttgen, and H. Bos. DSIbin: Identifying dynamic data structures in C/C++ binaries. In 32nd Intl. Conf. on Automated Software Engineering (ASE ’17). IEEE/ACM, 2017. Accepted for publication.
3. [Howard: A dynamic excavator for reverse engineering data structures][3]

[3]:https://www.isoc.org/isoc/conferences/ndss/11/pdf/5_1.pdf
